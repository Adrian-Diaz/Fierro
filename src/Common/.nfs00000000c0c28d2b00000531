/* input.c */                                                             

#include <string.h>
#include <sys/stat.h>
#include <iostream>
#include <stdlib.h>
#include <stdio.h>


#include "utilities.h"
#include "state.h"
#include "geometry.h"
#include "variables.h"


using namespace utils;
// -----------------------------------------------------------------------------
// This is the input function
//------------------------------------------------------------------------------
void input(){


    // ---- Method Choice ---- //
    CCH = false;
    SGH = false;
    DGH = true;



    p_order = 3;

    // ---- time varaibles and cycle info ---- //
    // time step
    TFINAL = 1.0;
    

    dt_min = 1.e-8;
    dt_max = 1.e-2;
    dt_start = 1.e-5;
    
    cycle_stop = 100;

    rk_num_stages = 2;

    rk_storage = 2;

    dt_cfl = 0.5;

    // ---- graphics information ---- //
    graphics_cyc_ival = 2;
    graphics_dt_ival  = 0.1;    // every 0.1 time units




    // ---- EOS parameters and material model ---- //
    NR = 1;
    material = (material_t *) malloc((size_t)(NR*sizeof(material_t)));
    
    material[0].eos_func = ideal_gas; // EOS model
    material[0].cv       = 1.0;       // specific heat
    material[0].csmin    = 0.1;       // minimum sound speed
    material[0].g        = 1.4;       // gamma value
    material[0].b1       = 1.3333;    // linear slope of UsUp for Riemann solver


    // ---- fill instructions and intial conditions ---- //
    
    // Problem choice //
    // 1 = sedov (set up for 3D 30x30x30 mesh)
    // 2 = sod x  (set up for 3D 2x1x1 mesh)
    // 3 = sod y  (set up for 3D 1x200x1 mesh)
    // 4 = sod z  (set up for 3D 1x1x200 mesh)
    // 5 = double rarefaction (set up for 3D 30x1x1 mesh)
    // 6 = Noh 3D

    int test_problem = 1;

    // SEDOV on a 30x30x30 mesh
    if (test_problem == 1){

        // currently set up for sedov blast wave 
        material[0].g        = 5.0/3.0;   // gamma value

        NF = 2; // number of fills
        
        mat_fill = (mat_fill_t *) malloc((size_t)(NF*sizeof(mat_fill_t)));
        
        // Global instructions
        mat_fill[0].volume = region::global;   // fill everywhere
        mat_fill[0].mat_id = 0;                // material id
        mat_fill[0].r = 1.0;                   // intial density
        mat_fill[0].ie = 1.e-10;               // intial specific internal energy
        mat_fill[0].u = 0.0;                   // initial x-dir velocity
        mat_fill[0].v = 0.0;
        mat_fill[0].w = 0.0;
        
        // Specific instructions
        mat_fill[1].volume = region::sphere;// fill a sphere
        mat_fill[1].mat_id = 0;             // material id
        mat_fill[1].radius1 = 0.0;          // inner radius of fill region
        
        // mat_fill[1].radius2 = 1.2/30.0;     // outer radius of fill region
        mat_fill[1].radius2 = 1.0;     // outer radius of fill region

        // mat_fill[1].radius2 = 1.2/6.0;     // outer radius of fill region

        // mat_fill[1].radius2 = 1.2/12.0;     // outer radius of fill region
        
        // mat_fill[1].radius2 = 1.0;     // outer radius of fill region
        
        mat_fill[1].r = 1.0;                // initial density
        
        // 30x30x30 cells
        // mat_fill[1].ie = 963.652344;
        
        // 2x2x2 cells
        // mat_fill[1].ie = (963.652344*pow((1.2/30.0),3))/pow((1.2/2.0),3);

        // 6x6x6 cells
        // mat_fill[1].ie = (963.652344*pow((1.2/30.0),3))/pow((1.2/6.0),3);

        // 4x4x4 cells
        // mat_fill[1].ie = (963.652344*pow((1.2/30.0),3))/pow((1.2/4.0),3);
        
        // EXTENSIVE SOURCE TERM = 0.493390

        // 12x12x12 cells
        
        // WARNING: WEIRD  FIX
        mat_fill[1].ie = (963.652344*pow((1.2/30.0),3))/pow((1.2/12.0),3);

        // mat_fill[1].ie = 61.67376/4.0;

        // mat_fill[1].ie = 18.27;

        // mat_fill[1].ie = 493.39;

        mat_fill[1].u = 0.0;              // initial x-dir velocity
        mat_fill[1].v = 0.0;
        mat_fill[1].w = 0.0;
        



        // ---- boundary conditions ---- //
        NB = 3; // number of boundaries
        // // allocate boundary memory
        boundary = (boundary_t *) malloc((size_t)(NB*sizeof(boundary_t)));
        
        // Tag X plane
        boundary[0].surface = bdy::x_plane; // planes, cylinder, spheres, or a files
        boundary[0].value = 0.0;
        boundary[0].hydro_bc = bdy::reflected;
        
        // Tag Y plane
        boundary[1].surface = bdy::y_plane;
        boundary[1].value = 0.0;
        boundary[1].hydro_bc = bdy::reflected;
        
        // Tag Z plane
        boundary[2].surface = bdy::z_plane;
        boundary[2].value = 0.0;
        boundary[2].hydro_bc = bdy::reflected;


    }
    
    // Sod in X on a 200x1x1 mesh
    if (test_problem == 2){

        // currently set up for sedov blast wave 

        NF = 2; // number of fills
        
        mat_fill = (mat_fill_t *) malloc((size_t)(NF*sizeof(mat_fill_t)));
        
        // Global instructions
        mat_fill[0].volume = region::global;   // fill everywhere
        mat_fill[0].mat_id = 0;                // material id
        mat_fill[0].r = 1.0;                   // intial density
        mat_fill[0].ie = 2.5;               // intial specific internal energy
        mat_fill[0].u = 0.0;                   // initial x-dir velocity
        mat_fill[0].v = 0.0;
        mat_fill[0].w = 0.0;
        
        // Specific instructions
        mat_fill[1].volume = region::box; // fill a box
        mat_fill[1].mat_id = 0;             // material id
        
        mat_fill[1].x1 = 0.6;          // 
        mat_fill[1].x2 = 1.2;           // 
        
        mat_fill[1].y1 = 0.0;          // 
        mat_fill[1].y2 = 0.12;          // 
        
        mat_fill[1].z1 = 0.0;          // 
        mat_fill[1].z2 = 0.12;          // 
        
        mat_fill[1].r = 0.1;            
        
        // 30x1x1 cells
        mat_fill[1].ie = 2.5;
        
        mat_fill[1].u = 0.0;              // initial x-dir velocity
        mat_fill[1].v = 0.0;
        mat_fill[1].w = 0.0;
            

        // ---- boundary conditions ---- //
        NB = 6; // number of boundaries
        // allocate boundary memory
        boundary = (boundary_t *) malloc((size_t)(NB*sizeof(boundary_t)));
        
        // Tag X = 0 plane
        boundary[0].surface = bdy::x_plane; // planes, cylinder, spheres, or a files
        boundary[0].value = 0.0;
        boundary[0].hydro_bc = bdy::reflected;
        
        // Tag Y = 0 plane
        boundary[1].surface = bdy::y_plane;
        boundary[1].value = 0.0;
        boundary[1].hydro_bc = bdy::reflected;
        
        // Tag Z = 0 plane
        boundary[2].surface = bdy::z_plane;
        boundary[2].value = 0.0;
        boundary[2].hydro_bc = bdy::reflected;
        
        // Tag X = 100 plane
        boundary[3].surface = bdy::x_plane; // planes, cylinder, spheres, or a files
        boundary[3].value = 1.2;
        boundary[3].hydro_bc = bdy::reflected;
        
        // Tag Y = 1 plane
        boundary[4].surface = bdy::y_plane;
        boundary[4].value = 0.12;
        boundary[4].hydro_bc = bdy::reflected;
        
        // Tag Z = 1 plane
        boundary[5].surface = bdy::z_plane;
        boundary[5].value = 0.12;
        boundary[5].hydro_bc = bdy::reflected;
    
    }


    // Sod in y on a 1x200x1 mesh
    if (test_problem == 3){

        material[0].g = 1.4;   // gamma value

        NF = 2; // number of fills
        
        mat_fill = (mat_fill_t *) malloc((size_t)(NF*sizeof(mat_fill_t)));
        
        // Global instructions
        mat_fill[0].volume = region::global;   // fill everywhere
        mat_fill[0].mat_id = 0;                // material id
        mat_fill[0].r = 1.0;                   // intial density
        mat_fill[0].ie = 2.5;               // intial specific internal energy
        mat_fill[0].u = 0.0;                   // initial x-dir velocity
        mat_fill[0].v = 0.0;
        mat_fill[0].w = 0.0;
        
        // Specific instructions
        mat_fill[1].volume = region::box; // fill a box
        mat_fill[1].mat_id = 0;             // material id
        
        mat_fill[1].x1 = 0;          // 
        mat_fill[1].x2 = 1;           // 
        
        mat_fill[1].y1 = 50;          // 
        mat_fill[1].y2 = 100;          // 
        
        mat_fill[1].z1 = 0;          // 
        mat_fill[1].z2 = 1;          // 
        
        mat_fill[1].r = 0.1;            
        
        // 30x1x1 cells
        mat_fill[1].ie = 2.5;
        
        mat_fill[1].u = 0.0;              // initial x-dir velocity
        mat_fill[1].v = 0.0;
        mat_fill[1].w = 0.0;
            

        // ---- boundary conditions ---- //
        NB = 6; // number of boundaries
        // allocate boundary memory
        boundary = (boundary_t *) malloc((size_t)(NB*sizeof(boundary_t)));
        
        // Tag X = 0 plane
        boundary[0].surface = bdy::x_plane; // planes, cylinder, spheres, or a files
        boundary[0].value = 0.0;
        boundary[0].hydro_bc = bdy::reflected;
        
        // Tag Y = 0 plane
        boundary[1].surface = bdy::y_plane;
        boundary[1].value = 0.0;
        boundary[1].hydro_bc = bdy::reflected;
        
        // Tag Z = 0 plane
        boundary[2].surface = bdy::z_plane;
        boundary[2].value = 0.0;
        boundary[2].hydro_bc = bdy::reflected;
        
        // Tag X = 1 plane
        boundary[3].surface = bdy::x_plane; // planes, cylinder, spheres, or a files
        boundary[3].value = 1.0;
        boundary[3].hydro_bc = bdy::reflected;
        
        // Tag Y = 100 plane
        boundary[4].surface = bdy::y_plane;
        boundary[4].value = 100.0;
        boundary[4].hydro_bc = bdy::reflected;
        
        // Tag Z = 1 plane
        boundary[5].surface = bdy::z_plane;
        boundary[5].value = 1.0;
        boundary[5].hydro_bc = bdy::reflected;
    
    }


    // Sod in Z on a 1x1x200 mesh
    if (test_problem == 4){

        // currently set up for sedov blast wave 

        NF = 2; // number of fills
        
        mat_fill = (mat_fill_t *) malloc((size_t)(NF*sizeof(mat_fill_t)));
        
        // Global instructions
        mat_fill[0].volume = region::global;   // fill everywhere
        mat_fill[0].mat_id = 0;                // material id
        mat_fill[0].r = 1.0;                   // intial density
        mat_fill[0].ie = 2.5;               // intial specific internal energy
        mat_fill[0].u = 0.0;                   // initial x-dir velocity
        mat_fill[0].v = 0.0;
        mat_fill[0].w = 0.0;
        
        // Specific instructions
        mat_fill[1].volume = region::box; // fill a box
        mat_fill[1].mat_id = 0;             // material id
        
        mat_fill[1].x1 = 0;          // 
        mat_fill[1].x2 = 1;           // 
        
        mat_fill[1].y1 = 0;          // 
        mat_fill[1].y2 = 1;          // 
        
        mat_fill[1].z1 = 50;          // 
        mat_fill[1].z2 = 100;          // 
        
        mat_fill[1].r = 0.1;            
        
        // 30x1x1 cells
        mat_fill[1].ie = 2.5;
        
        mat_fill[1].u = 0.0;              // initial x-dir velocity
        mat_fill[1].v = 0.0;
        mat_fill[1].w = 0.0;
            

        // ---- boundary conditions ---- //
        NB = 6; // number of boundaries
        // allocate boundary memory
        boundary = (boundary_t *) malloc((size_t)(NB*sizeof(boundary_t)));
        
        // Tag X = 0 plane
        boundary[0].surface = bdy::x_plane; // planes, cylinder, spheres, or a files
        boundary[0].value = 0.0;
        boundary[0].hydro_bc = bdy::reflected;
        
        // Tag Y = 0 plane
        boundary[1].surface = bdy::y_plane;
        boundary[1].value = 0.0;
        boundary[1].hydro_bc = bdy::reflected;
        
        // Tag Z = 0 plane
        boundary[2].surface = bdy::z_plane;
        boundary[2].value = 0.0;
        boundary[2].hydro_bc = bdy::reflected;
        
        // Tag X = 1 plane
        boundary[3].surface = bdy::x_plane; // planes, cylinder, spheres, or a files
        boundary[3].value = 1.0;
        boundary[3].hydro_bc = bdy::reflected;
        
        // Tag Y = 1 plane
        boundary[4].surface = bdy::y_plane;
        boundary[4].value = 1.0;
        boundary[4].hydro_bc = bdy::reflected;
        
        // Tag Z = 100 plane
        boundary[5].surface = bdy::z_plane;
        boundary[5].value = 100.0;
        boundary[5].hydro_bc = bdy::reflected;
    
    }


    // Double rarefaction in X
    if (test_problem == 5){

        // currently set up for sedov blast wave 

        NF = 2; // number of fills
        
        mat_fill = (mat_fill_t *) malloc((size_t)(NF*sizeof(mat_fill_t)));
        
        // Global instructions
        mat_fill[0].volume = region::global;   // fill everywhere
        mat_fill[0].mat_id = 0;                // material id
        mat_fill[0].r = 1.0;                   // intial density
        mat_fill[0].ie = 2.5;               // intial specific internal energy
        
        mat_fill[0].u = -2.0;                   // initial x-dir velocity
        mat_fill[0].v = 0.0;
        mat_fill[0].w = 0.0;
        
        // Specific instructions
        mat_fill[1].volume = region::box; // fill a box
        mat_fill[1].mat_id = 0;             // material id
        
        mat_fill[1].x1 = 0.5;          // 
        mat_fill[1].x2 = 1.0;           // 
        
        mat_fill[1].y1 = 0.0;          // 
        mat_fill[1].y2 = 0.1;          // 
        
        mat_fill[1].z1 = 0.0;          // 
        mat_fill[1].z2 = 0.1;          // 
        
        mat_fill[1].r = 1.0;            
        

        mat_fill[1].ie = 2.5;
        
        mat_fill[1].u = 2.0;              // initial x-dir velocity
        mat_fill[1].v = 0.0;
        mat_fill[1].w = 0.0;
            

        // ---- boundary conditions ---- //
        NB = 6; // number of boundaries
        // allocate boundary memory
        boundary = (boundary_t *) malloc((size_t)(NB*sizeof(boundary_t)));
        
        // Tag X = 0 plane
        boundary[0].surface = bdy::x_plane; // planes, cylinder, spheres, or a files
        boundary[0].value = 0.0;
        boundary[0].hydro_bc = bdy::reflected;
        
        // Tag Y = 0 plane
        boundary[1].surface = bdy::y_plane;
        boundary[1].value = 0.0;
        boundary[1].hydro_bc = bdy::reflected;
        
        // Tag Z = 0 plane
        boundary[2].surface = bdy::z_plane;
        boundary[2].value = 0.0;
        boundary[2].hydro_bc = bdy::reflected;
        
        // Tag X = 100 plane
        boundary[3].surface = bdy::x_plane; // planes, cylinder, spheres, or a files
        boundary[3].value = 1.0;
        boundary[3].hydro_bc = bdy::reflected;
        
        // Tag Y = 1 plane
        boundary[4].surface = bdy::y_plane;
        boundary[4].value = 0.1;
        boundary[4].hydro_bc = bdy::reflected;
        
        // Tag Z = 1 plane
        boundary[5].surface = bdy::z_plane;
        boundary[5].value = 0.1;
        boundary[5].hydro_bc = bdy::reflected;
    
    }

    // Noh 3D
    if (test_problem == 6){


        material[0].g        = 5.0/3.0;   // gamma value

        NF = 1; // number of fills
        
        mat_fill = (mat_fill_t *) malloc((size_t)(NF*sizeof(mat_fill_t)));
        
        // Global instructions
        mat_fill[0].volume = region::global;   // fill everywhere
        mat_fill[0].mat_id = 0;                // material id
        mat_fill[0].r = 1.0;                   // intial density
        mat_fill[0].ie = 1e-9;             // intial specific internal energy
        
        mat_fill[0].u = 0.0;                   // initial x-dir velocity
        mat_fill[0].v = 0.0;
        mat_fill[0].w = 0.0;
        

            

        // ---- boundary conditions ---- //
        NB = 3; // number of boundaries
        
        // allocate boundary memory
        boundary = (boundary_t *) malloc((size_t)(NB*sizeof(boundary_t)));
        
        // Tag X = 0 plane
        boundary[0].surface = bdy::x_plane; // planes, cylinder, spheres, or a files
        boundary[0].value = 0.0;
        boundary[0].hydro_bc = bdy::reflected;
        
        // Tag Y = 0 plane
        boundary[1].surface = bdy::y_plane;
        boundary[1].value = 0.0;
        boundary[1].hydro_bc = bdy::reflected;
        
        // Tag Z = 0 plane
        boundary[2].surface = bdy::z_plane;
        boundary[2].value = 0.0;
        boundary[2].hydro_bc = bdy::reflected;
        

    }



} // end of input


